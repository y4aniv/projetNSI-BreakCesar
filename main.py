"""
BreakCesar - DÃ©chiffrement automatique d'un code CÃ©sar
Auteur : Yaniv & OcÃ©anely
WebApp: https://breakcesar.streamlit.app/
"""

#Importation des modules.
import streamlit as st
from st_cytoscape import cytoscape
from langdetect import detect, DetectorFactory

## Dictionnaire des lettres les plus frÃ©quentes dans chaque langue
freq_lang = {
    "Anglais": "e",
    "FranÃ§ais": "e",
    "Allemand": "e",
    "Espagnol": "e",
    "Portugais": "a",
    "Italien": "e",
    "Turc": "a",
    "SuÃ©dois": "e",
    "Polonais": "a",
    "Danois": "e",
    "Finnois": "a",
    "TchÃ¨que": "a",
    "Lituanien": "i"
}


def analyse_frequence(texte):
    """
    Analyse la frÃ©quence des lettres dans un texte
    -> text <str>
    <- freq <dict>
    """

    ## Initialisation du dictionnaire
    freq = {}
    ## Parcours du texte
    for caractere in texte:
        ## Conversion en minuscule
        caractere = caractere.lower()
        ## Si le caractÃ¨re n'est pas une lettre, on passe au suivant
        if not caractere.isalpha():
            continue
        ## Si le caractÃ¨re est dÃ©jÃ  dans le dictionnaire, on incrÃ©mente sa valeur
        if caractere in freq:
            freq[caractere] += 1
        ## Sinon, on l'ajoute au dictionnaire
        else:
            freq[caractere] = 1
    ## On retourne le dictionnaire
    return freq

def pourcentage_frequence(freq):
    """
    Convertit les valeurs d'un dictionnaire en pourcentage
    -> freq <dict>
    <- freq <dict>
    """
    ## Calcul du total des valeurs. Utilisation de sum() pour Ã©viter une boucle et amÃ©liorer les performances
    total = sum(freq.values())
    ## Parcours du dictionnaire
    for caractere in freq:
        ## Calcul du pourcentage
        freq[caractere] = (freq[caractere] / total) * 100
    ## On retourne le dictionnaire
    return freq

def caractere_plus_frequent(freq):
    """
    Retourne le caractÃ¨re le plus frÃ©quent dans un dictionnaire
    -> freq <dict>
    <- max_caractere <str>
    """
    ## Initialisation de la variable
    max_caractere = ""
    ## Parcours du dictionnaire
    for caractere in freq:
        ## Si le caractÃ¨re est le plus frÃ©quent, on le stocke
        if max_caractere == "" or freq[caractere] > freq[max_caractere]:
            max_caractere = caractere
    ## On retourne le caractÃ¨re le plus frÃ©quent
    return max_caractere

def difference_caracteres(caractere1, caractere2):
    """
    Retourne la diffÃ©rence entre deux caractÃ¨res
    -> caractere1 <str>, caractere2 <str>
    <- pos2 - pos1 <int>
    """
    ## Conversion des caractÃ¨res en nombres avec la table ASCII
    pos1 = ord(caractere1) - 97 ## On soustrait 97 pour obtenir la position dans l'alphabet car la table ASCII commence Ã  97 pour les minuscules
    pos2 = ord(caractere2) - 97 ## On soustrait 97 pour obtenir la position dans l'alphabet car la table ASCII commence Ã  97 pour les minuscules
    ## On retourne la diffÃ©rence entre les deux caractÃ¨res
    return pos2 - pos1

def dechiffrer_cesar(texte, lang="FranÃ§ais"):
    """
    DÃ©chiffre un texte chiffrÃ© avec un code CÃ©sar
    -> texte <str>, lang <str>
    <- texte_dechiffre <str>
    """
    ## Analyse de la frÃ©quence des lettres dans le texte
    freq = analyse_frequence(texte)
    ## Conversion des valeurs en pourcentage
    freq = pourcentage_frequence(freq)
    ## RÃ©cupÃ©ration du caractÃ¨re le plus frÃ©quent
    max_caractere = caractere_plus_frequent(freq)
    ## Calcul de la diffÃ©rence entre le caractÃ¨re le plus frÃ©quent et le caractÃ¨re le plus frÃ©quent dans la langue
    diff = difference_caracteres(max_caractere, freq_lang[lang])
    ## Initialisation de la variable
    texte_dechiffre = ""
    ## Parcours du texte
    for caractere in texte:
        ## Conversion en minuscule
        caractere_lower = caractere.lower()
        ## Si le caractÃ¨re n'est pas une lettre, on l'ajoute au texte dÃ©chiffrÃ©
        if caractere_lower in "abcdefghijklmnopqrstuvwxyz":
            ## Calcul de la nouvelle position du caractÃ¨re
            pos = ord(caractere_lower) - 97 ## On soustrait 97 pour obtenir la position dans l'alphabet car la table ASCII commence Ã  97 pour les minuscules
            ## Calcul de la nouvelle position du caractÃ¨re
            nouvelle_pos = (pos + diff) % 26 ## On utilise le modulo 26 pour Ã©viter de dÃ©passer 26
            ## Conversion de la nouvelle position en caractÃ¨re
            nouveau_caractere = chr(nouvelle_pos + 97) ## On ajoute 97 pour obtenir la position dans la table ASCII
            ## Si le caractÃ¨re Ã©tait en majuscule, on le convertit
            if caractere.isupper():
                nouveau_caractere = nouveau_caractere.upper()
            ## Ajout du caractÃ¨re au texte dÃ©chiffrÃ©
            texte_dechiffre += nouveau_caractere
        else:
            texte_dechiffre += caractere
    ## On retourne le texte dÃ©chiffrÃ©
    return texte_dechiffre

def reset_session(type):
    """
    RÃ©initialise les variables de session
    -> type <str>
    <- None
    """
    ## RÃ©initialisation des variables de session 
    st.session_state["demoState"] = True
    st.session_state["demoType"] = type

def iso3166_to_lang(iso3166):
    """
    Convertit un code ISO 3166-1 en langue
    -> iso3166 <str>
    <- lang <str>
    """
    lang = {
        "en": "Anglais",
        "fr": "FranÃ§ais",
        "de": "Allemand",
        "es": "Espagnol",
        "pt": "Portugais",
        "it": "Italien",
        "tr": "Turc",
        "sv": "SuÃ©dois",
        "pl": "Polonais",
        "da": "Danois",
        "fi": "Finnois",
        "cs": "TchÃ¨que",
        "lt": "Lituanien"
    }

    return lang[iso3166]

## Configuration de la page
st.set_page_config(page_title="BreakCesar", page_icon="ðŸ”“", layout="centered", initial_sidebar_state="auto")

## Titre et sous-titre
st.title("ðŸ”“ BreakCesar")
st.subheader("DÃ©chiffrement automatique d'un code CÃ©sar")

try:
        ## Titre de la section
    st.sidebar.write("# DÃ©monstration")

    ## Initialisation des variables de session si elles n'existent pas
    if 'demoState' not in st.session_state:
        ## La variable de session demoState permet de savoir si un texte chiffrÃ© a Ã©tÃ© sÃ©lectionnÃ©
        st.session_state['demoState'] = False
    if 'demoType' not in st.session_state:
        ## La variable de session demoType permet de savoir quel texte chiffrÃ© a Ã©tÃ© sÃ©lectionnÃ©
        st.session_state['demoType'] = ""
    if 'file_uploader_key' not in st.session_state:
        ## La variable de session file_uploader_key permet de rÃ©initialiser le file_uploader
        st.session_state['file_uploader_key'] = 0

    ## Boutons de dÃ©monstration
    demo_frLong = st.sidebar.button("Test en FranÃ§ais [925 caractÃ¨res] > ClÃ© de chiffrement : 5")
    demo_trLong = st.sidebar.button("Test en Turc [710 caractÃ¨res] > ClÃ© de chiffrement : 18")
    demo_sdLong = st.sidebar.button("Test en SuÃ©dois [22434 caractÃ¨res] > ClÃ© de chiffrement : 65")
    demo_enCourt = st.sidebar.button("Test en Anglais [29 caractÃ¨res] > ClÃ© de chiffrement : 1")
    demo_frAsLt = st.sidebar.button("Test d'un texte en FranÃ§ais dÃ©chiffrÃ© en Lituanien [925 caractÃ¨res] > ClÃ© de chiffrement : 5")
    st.sidebar.write("")

    ## Panel de test personnalisÃ©
    st.sidebar.write("# Testez votre propre texte")
    langue = st.sidebar.selectbox("SÃ©lectionnez la langue du texte chiffrÃ©", list(freq_lang.keys()))
    fichier_chiffre = st.sidebar.file_uploader("Uploadez le fichier chiffrÃ© (.txt)", key=st.session_state['file_uploader_key'], type="txt")

    ## Si un bouton de dÃ©monstration est cliquÃ©, on rÃ©initialise les variables de session
    if demo_frLong or demo_trLong or demo_enCourt or demo_frAsLt or fichier_chiffre or demo_sdLong:
        reset_session("frLong" if demo_frLong else "trLong" if demo_trLong else "enCourt" if demo_enCourt else "frAsLt" if demo_frAsLt else "demo_sdLong" if demo_sdLong else "fichier")
        if demo_frLong or demo_trLong or demo_enCourt or demo_frAsLt or demo_sdLong:
            st.session_state["file_uploader_key"] += 1
            st.rerun()

    ## Routage des diffÃ©rentes valeurs de demonstration
    if st.session_state.demoState:
        ## Si un texte par dÃ©faut est sÃ©lectionnÃ©, on rÃ©cupÃ¨re le texte et la langue
        if st.session_state.demoType == "frLong":
            donnees_crypter = open('./assets/frLong.txt', 'r').read()
            langue = "FranÃ§ais"
        elif st.session_state.demoType == "trLong":
            donnees_crypter = open('./assets/trLong.txt', 'r').read()
            langue = "Turc"
        elif st.session_state.demoType == "enCourt":
            donnees_crypter = open('./assets/enCourt.txt', 'r').read()
            langue = "Anglais"
        elif st.session_state.demoType == "frAsLt":
            donnees_crypter = open('./assets/frLong.txt', 'r').read()
            langue = "Lituanien"
        elif st.session_state.demoType == "demo_sdLong":
            donnees_crypter = open('./assets/sdLong.txt', 'r').read()
            langue = "SuÃ©dois"
        ## Si un fichier est uploadÃ©, on rÃ©cupÃ¨re le contenu du fichier 
        elif st.session_state.demoType == "fichier":
            donnees_crypter = fichier_chiffre.read().decode("utf-8")
        
        ## Affichage du texte chiffrÃ©
        st.write("## Texte chiffrÃ©")
        # Maximum de 1000 caractÃ¨res pour Ã©viter les problÃ¨mes de performances.
        st.write(donnees_crypter[:1000] + (f"... **{len(donnees_crypter) - 1000} caractÃ¨res restant**" if len(donnees_crypter) > 1000 else ""))

        ## Affichage du texte dÃ©chiffrÃ©
        st.write("## Texte dÃ©chiffrÃ©")
        # Maximum de 1000 caractÃ¨res pour Ã©viter les problÃ¨mes de performances.
        st.write(dechiffrer_cesar(donnees_crypter, langue)[:1000] + (f"... **{len(donnees_crypter) - 1000} caractÃ¨res restant**" if len(donnees_crypter) > 1000 else ""))

        ## Affichage des informations
        st.write("## Informations")
        ## Calcul de la diffÃ©rence entre le caractÃ¨re le plus frÃ©quent et le caractÃ¨re le plus frÃ©quent dans la langue
        diff = abs(difference_caracteres(caractere_plus_frequent(analyse_frequence(donnees_crypter)), freq_lang[langue]))

        founded = 0

        wordlist = open(f'./assets/wordlists/{langue}.txt', 'r').read()
        for word in dechiffrer_cesar(donnees_crypter, langue).split(" "):
            if word in wordlist:
                founded += 1
        
        score = founded / len(dechiffrer_cesar(donnees_crypter, langue).split(" "))

        DetectorFactory.seed = 0
        langue_detectee = iso3166_to_lang(detect(dechiffrer_cesar(donnees_crypter, langue)))

        if(score > 0.5):
            if(langue_detectee.lower() != langue.lower()):
                st.warning(f"Le texte ne semble pas avoir Ã©tÃ© dÃ©chiffrÃ© avec succÃ¨s... (score: {score} - Erreur dans la concordance de la langue)")
            else:
                st.success(f"Le texte Ã  Ã©tÃ© dÃ©chiffrÃ© avec succÃ¨s ! (score: {score})")
        else:
            st.warning(f"Le texte ne semble pas avoir Ã©tÃ© dÃ©chiffrÃ© avec succÃ¨s... (score: {score})")

        ## Informations de base
        st.info(f"La lettre la plus frÃ©quente en **{langue}** est **{freq_lang[langue].upper()}**")
        st.info(f"Avec une clÃ© de **{diff}**, la lettre **{freq_lang[langue].upper()}** devient **{caractere_plus_frequent(analyse_frequence(donnees_crypter)).upper()}** aprÃ¨s chiffrement")

        ## Affichage de la clÃ© de chiffrement
        st.write(f"### ClÃ© de chiffrement (valeur estimÃ©e) : {diff}")
        st.write(
            "La clÃ© de chiffrement est une valeur estimÃ©e Ã©tant donnÃ© que, dÃ¨s que l'on atteint le chiffre 26, l'alphabet recommence. Ainsi, plusieurs clÃ©s de chiffrement peuvent Ãªtre gÃ©nÃ©rÃ©es."
        )
        st.write(f"D'autres clÃ©s de chiffrement sont possibles, telles que : **{diff+26}, {diff+52}, ...**")
        st.write(f'La valeur **{diff}** est la plus petite possible et reprÃ©sente le nombre de lettres Ã  dÃ©caler pour chiffrer le texte.')

        ## Initialisation du dictionnaire contenant les Ã©lÃ©ments du graphique
        elements = []

        for i in range(26):
            elements.append({"data": {"id": f"c{str(i)}", "label": chr(i + 97).upper()}})
        for i in range(26):
            elements.append({"data": {"id": f"d{str(i)}", "label": chr(i + 97).upper()}})
        for i in range(26):
            elements.append({"data": {"source": f"c{str(i)}", "target": f"d{str((i + diff) % 26)}"}})

        ## Ajout de styles
        stylesheet = [
            {"selector": "node", "style": {"label": "data(label)", "width": 20, "height": 20}},
            {
                "selector": "edge",
                "style": {
                    "width": 3
                },
            },
            {
                "selector": "[id ^= 'c']",
                "style": {
                    "background-color": "#ff0000",
                    "shape": "rectangle",
                },
            },
            {
                "selector": "[id ^= 'd']",
                "style": {
                    "background-color": "#00ff00",
                    "shape": "rectangle",
                },
            },
        ]

        ## Configuration du layout du graphique
        layout = {"name": "grid", "rows": 2}

        ## Affichage du graphique
        st.write("## Visualisation")
        cytoscape(elements, stylesheet, key="graph", layout=layout)

    else:
        ## Si aucun texte chiffrÃ© n'est sÃ©lectionnÃ©, on affiche un message d'erreur
        st.warning("Aucun texte chiffrÃ© n'a Ã©tÃ© sÃ©lectionnÃ©")
except Exception as e:
    ## Si une erreur se produit, on affiche un message d'erreur
    st.error("Une erreur s'est produite")
    st.error(e)
