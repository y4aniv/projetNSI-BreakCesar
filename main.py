"""
Importation des modules.
Streamlit est utilisÃ© pour l'interface graphique et st_cytoscape pour la visualisation du chiffrement.
"""
import streamlit as st
from st_cytoscape import cytoscape

## Dictionnaire des frÃ©quences des lettres dans chaque langue
freq_lang = {
    "Anglais": "e",
    "FranÃ§ais": "e",
    "Allemand": "e",
    "Espagnol": "e",
    "Portugais": "a",
    "Italien": "e",
    "Turc": "a",
    "SuÃ©dois": "e",
    "Polonais": "a",
    "NÃ©erlandais": "e",
    "Danois": "e",
    "Islandais": "a",
    "Finnois": "a",
    "TchÃ¨que": "a",
    "Lituanien": "i"
}

def analyse_frequence(texte):
    """
    Analyse la frÃ©quence des lettres dans un texte
    -> text <str>
    <- freq <dict>
    """

    ## Initialisation du dictionnaire
    freq = {}
    ## Parcours du texte
    for caractere in texte:
        ## Conversion en minuscule
        caractere = caractere.lower()
        ## Si le caractÃ¨re n'est pas une lettre, on passe au suivant
        if not caractere.isalpha():
            continue
        ## Si le caractÃ¨re est dÃ©jÃ  dans le dictionnaire, on incrÃ©mente sa valeur
        if caractere in freq:
            freq[caractere] += 1
        ## Sinon, on l'ajoute au dictionnaire
        else:
            freq[caractere] = 1
    ## On retourne le dictionnaire
    print(freq)
    return freq

def pourcentage_frequence(freq):
    """
    Convertit les valeurs d'un dictionnaire en pourcentage
    -> freq <dict>
    <- freq <dict>
    """
    ## Calcul du total des valeurs. Utilisation de sum() pour Ã©viter une boucle et amÃ©liorer les performances
    total = sum(freq.values())
    ## Parcours du dictionnaire
    for caractere in freq:
        ## Calcul du pourcentage
        freq[caractere] = (freq[caractere] / total) * 100
    ## On retourne le dictionnaire
    return freq

def caractere_plus_frequent(freq):
    """
    Retourne le caractÃ¨re le plus frÃ©quent dans un dictionnaire
    -> freq <dict>
    <- max_caractere <str>
    """
    ## Initialisation de la variable
    max_caractere = ""
    ## Parcours du dictionnaire
    for caractere in freq:
        ## Si le caractÃ¨re est le plus frÃ©quent, on le stocke
        if max_caractere == "" or freq[caractere] > freq[max_caractere]:
            max_caractere = caractere
    ## On retourne le caractÃ¨re le plus frÃ©quent
    return max_caractere

def difference_caracteres(caractere1, caractere2):
    """
    Retourne la diffÃ©rence entre deux caractÃ¨res
    -> caractere1 <str>, caractere2 <str>
    <- pos2 - pos1 <int>
    """
    ## Conversion des caractÃ¨res en nombres avec la table ASCII
    pos1 = ord(caractere1) - 97 ## On soustrait 97 pour obtenir la position dans l'alphabet car la table ASCII commence Ã  97 pour les minuscules
    pos2 = ord(caractere2) - 97 ## On soustrait 97 pour obtenir la position dans l'alphabet car la table ASCII commence Ã  97 pour les minuscules
    ## On retourne la diffÃ©rence entre les deux caractÃ¨res
    return pos2 - pos1

def dechiffrer_cesar(texte, lang="FranÃ§ais"):
    """
    DÃ©chiffre un texte chiffrÃ© avec un code CÃ©sar
    -> texte <str>, lang <str>
    <- texte_dechiffre <str>
    """
    ## Analyse de la frÃ©quence des lettres dans le texte
    freq = analyse_frequence(texte)
    ## Conversion des valeurs en pourcentage
    freq = pourcentage_frequence(freq)
    ## RÃ©cupÃ©ration du caractÃ¨re le plus frÃ©quent
    max_caractere = caractere_plus_frequent(freq)
    ## Calcul de la diffÃ©rence entre le caractÃ¨re le plus frÃ©quent et le caractÃ¨re le plus frÃ©quent dans la langue
    diff = difference_caracteres(max_caractere, freq_lang[lang])
    ## Initialisation de la variable
    texte_dechiffre = ""
    ## Parcours du texte
    for caractere in texte:
        ## Conversion en minuscule
        caractere_lower = caractere.lower()
        ## Si le caractÃ¨re n'est pas une lettre, on l'ajoute au texte dÃ©chiffrÃ©
        if caractere_lower in "abcdefghijklmnopqrstuvwxyz":
            ## Calcul de la nouvelle position du caractÃ¨re
            pos = ord(caractere_lower) - 97 ## On soustrait 97 pour obtenir la position dans l'alphabet car la table ASCII commence Ã  97 pour les minuscules
            ## Calcul de la nouvelle position du caractÃ¨re
            nouvelle_pos = (pos + diff) % 26 ## On utilise le modulo 26 pour Ã©viter de dÃ©passer 26
            ## Conversion de la nouvelle position en caractÃ¨re
            nouveau_caractere = chr(nouvelle_pos + 97) ## On ajoute 97 pour obtenir la position dans la table ASCII
            ## Si le caractÃ¨re Ã©tait en majuscule, on le convertit
            if caractere.isupper():
                nouveau_caractere = nouveau_caractere.upper()
            ## Ajout du caractÃ¨re au texte dÃ©chiffrÃ©
            texte_dechiffre += nouveau_caractere
        else:
            texte_dechiffre += caractere
    ## On retourne le texte dÃ©chiffrÃ©
    return texte_dechiffre

def reset_session(type):
    """
    RÃ©initialise les variables de session
    -> type <str>
    <- None
    """
    ## RÃ©initialisation des variables de session 
    st.session_state["demoState"] = True
    st.session_state["demoType"] = type

## Configuration de la page
st.set_page_config(page_title="BreakCesar", page_icon="ğŸ”“", layout="centered", initial_sidebar_state="auto")

## Titre et sous-titre
st.title("ğŸ”“ BreakCesar")
st.subheader("DÃ©chiffrement automatique d'un code CÃ©sar")

try:
        ## Titre de la section
    st.sidebar.write("# DÃ©monstration")

    ## Initialisation des variables de session si elles n'existent pas
    if 'demoState' not in st.session_state:
        ## La variable de session demoState permet de savoir si un texte chiffrÃ© a Ã©tÃ© sÃ©lectionnÃ©
        st.session_state['demoState'] = False
    if 'demoType' not in st.session_state:
        ## La variable de session demoType permet de savoir quel texte chiffrÃ© a Ã©tÃ© sÃ©lectionnÃ©
        st.session_state['demoType'] = ""
    if 'file_uploader_key' not in st.session_state:
        ## La variable de session file_uploader_key permet de rÃ©initialiser le file_uploader
        st.session_state['file_uploader_key'] = 0

    ## Boutons de dÃ©monstration
    demo_frLong = st.sidebar.button("Test en FranÃ§ais [925 caractÃ¨res] > ClÃ© de chiffrement : 5")
    demo_trLong = st.sidebar.button("Test en Turc [710 caractÃ¨res] > ClÃ© de chiffrement : 18")
    demo_enCourt = st.sidebar.button("Test en Anglais [29 caractÃ¨res] > ClÃ© de chiffrement : 1")
    demo_frAsLt = st.sidebar.button("Test d'un texte en FranÃ§ais dÃ©chiffrÃ© en Lituanien [925 caractÃ¨res] > ClÃ© de chiffrement : 5")
    st.sidebar.write("")

    ## Panel de test personnalisÃ©
    st.sidebar.write("# Testez votre propre texte")
    langue = st.sidebar.selectbox("SÃ©lectionnez la langue du texte chiffrÃ©", list(freq_lang.keys()))
    fichier_chiffre = st.sidebar.file_uploader("Uploadez le fichier chiffrÃ© (.txt)", key=st.session_state['file_uploader_key'], type="txt")
    st.sidebar.write("Supprimez le fichier stockÃ© pour retourner Ã  la dÃ©monstration")
    del_storage = st.sidebar.button("Supprimer le fichier stockÃ©")

    ## Si un bouton de dÃ©monstration est cliquÃ©, on rÃ©initialise les variables de session
    if demo_frLong or demo_trLong or demo_enCourt or demo_frAsLt or fichier_chiffre:
        reset_session("frLong" if demo_frLong else "trLong" if demo_trLong else "enCourt" if demo_enCourt else "frAsLt" if demo_frAsLt else "fichier")

    ## Si le bouton de suppression du fichier stockÃ© est cliquÃ©, on rÃ©initialise les variables de session et on supprime le fichier stockÃ© en incrÃ©mentant la clÃ© du file_uploader
    if del_storage:
        st.session_state["demoState"] = False
        st.session_state["demoType"] = ""
        st.session_state["file_uploader_key"] += 1
        st.rerun()

    ## Routage des diffÃ©rentes valeurs de demonstration
    if st.session_state.demoState:
        ## Si un texte par dÃ©faut est sÃ©lectionnÃ©, on rÃ©cupÃ¨re le texte et la langue
        if st.session_state.demoType == "frLong":
            donnees_crypter = "Jqqj jsatnj qj rfszxhwny Ã  Xnrtsj ij Gjfzatnw vzn xtzynjsy xf uzgqnhfynts fzc Ã‰inyntsx Lfqqnrfwi. Zsj htwwjxutsifshj x'Ã©yfgqny jsywj jqqjx Ã  qf kns ijx fssÃ©jx 1960. Jqqj qzn jcuwnrj fnsxn xjx jxuÃ©wfshjx jy xjx fyyjsyjx anx-Ã -anx i'zsj uzgqnhfynts ufw Lfqqnrfwi, zsj rfnxts i'Ã©inynts Ã  qf stytwnÃ©yÃ© nsyjwsfyntsfqj : Â« Xn atzx xfanje hj vzj o'fyyjsix ij hjyyj uzgqnhfynts ! Qf wzuyzwj fajh zsj anj ij wtzynsj jy ij wÃ©xnlsfynts, qf kznyj js ufdx Ã©ywfsljw, q'nsiÃ©ujsifshj ufw qj ywfafnq. Atzx atdje vz'nq sj x'flny ufx xnruqjrjsy utzw rtn i'zsj xnruqj vzjxynts ij afsnyÃ©. Utzw tgyjsnw q'fzytwnxfynts ij xtwynj, nq stzx kfzy i'fgtwi zsj fzytwnxfynts rfwnyfqj, uznx zsj fzywj tkknhnjqqj. Â», Ã©hwny-jqqj ifsx zs htzwwnjw ifyÃ© iz 23 iÃ©hjrgwj 196722. Uznx ifsx zs fzywj htzwwnjw, ifyÃ© hjyyj ktnx iz 5 ofsanjw 1968, jqqj Ã©hwny jshtwj : Â« Oj hwfnsx gjfzhtzu ij s'fatnw ufx fxxje i'fwljsy inxutsngqj utzw atdfljw ozxvz'Ã  Ufwnx. Oj htruyfnx ozxyjrjsy xzw zsj fafshj ij Lfqqnrfwi utzw qj kfnwj. Rts rfwn utzwwfny r'fnijw rfnx oj sj qj ajzc ufx. Stzx sj xtrrjx ufx js ywÃ¨x gtsx yjwrjx jy oj anx Ã  xjx hwthmjyx ijuznx ansly fsx"
            langue = "FranÃ§ais"
        elif st.session_state.demoType == "trLong":
            donnees_crypter = "Ewjzsts twf Sda. TmjskÄ± twfae gvse. Gvsevs rsesf ywÃ§ajewqa Ã§gc kwnwjae. Karw gvseÄ± sfdslesc aklaqgjme. GvseÄ± csjvwÅŸaedw hsqdsÅŸÄ±jÄ±e. VmnsjdsjÄ±fÄ±f jwfya esnavaj. Esna twfae wf kwnvaÄŸae jwfclaj. Ã‡sdÄ±ÅŸes eskse hwfuwjwfaf qsfÄ±fvsvÄ±j. Kstsz mqsfÄ±j mqsfesr hwfuwjwqa sÃ§sjÄ±e nw tajsr lwear zsns sdÄ±jÄ±e. TadyaksqsjÄ±e Ã§sdÄ±ÅŸes eskseÄ±f Ã¼klÃ¼fvwvaj. CsjvwÅŸae tskcwltgd gqfsesqÄ± Ã§gc kwnwj. Tm qÃ¼rvwf qslsÄŸÄ±fÄ±f sdlÄ±fvs taj tskcwltgd lghm nsjvÄ±j. Vmnsjvs vs tskcwltgd gqmfumdsjÄ±fÄ±f jwkaedwja nsjvÄ±j. CsjvwÅŸae tadyaksqsj gqmfdsjÄ±fÄ± kwnewr ses twf Ã§gc kwnwjae. Wf kwnvaÄŸae tadyaksqsj gqmfm sjsts qsjÄ±ÅŸÄ±vÄ±j. Ã–vwndwjaea qshlÄ±clsf kgfjs tajsr tadyaksqsj gqmfm gqfsj tajsr vs calsh gcmjme. YÃ¼fÃ¼f tÃ¼qÃ¼c cÄ±keÄ±fÄ± gvsevs ywÃ§ajajae. Tm qÃ¼rvwf gvseÄ±f lwear nw vÃ¼rwfda gdeskÄ±fs Ã§gc Ã¶fwe nwjajae. Fw vwjdwj tadajkafar: Skdsf qsllÄ±ÄŸÄ± qwjvwf twdda gdmj."
            langue = "Turc"
        elif st.session_state.demoType == "enCourt":
            donnees_crypter = "Ifmmp Xpsme! J'n Cpoe, Kbnft Cpoe."
            langue = "Anglais"
        elif st.session_state.demoType == "frAsLt":
            donnees_crypter = "Jqqj jsatnj qj rfszxhwny Ã  Xnrtsj ij Gjfzatnw vzn xtzynjsy xf uzgqnhfynts fzc Ã‰inyntsx Lfqqnrfwi. Zsj htwwjxutsifshj x'Ã©yfgqny jsywj jqqjx Ã  qf kns ijx fssÃ©jx 1960. Jqqj qzn jcuwnrj fnsxn xjx jxuÃ©wfshjx jy xjx fyyjsyjx anx-Ã -anx i'zsj uzgqnhfynts ufw Lfqqnrfwi, zsj rfnxts i'Ã©inynts Ã  qf stytwnÃ©yÃ© nsyjwsfyntsfqj : Â« Xn atzx xfanje hj vzj o'fyyjsix ij hjyyj uzgqnhfynts ! Qf wzuyzwj fajh zsj anj ij wtzynsj jy ij wÃ©xnlsfynts, qf kznyj js ufdx Ã©ywfsljw, q'nsiÃ©ujsifshj ufw qj ywfafnq. Atzx atdje vz'nq sj x'flny ufx xnruqjrjsy utzw rtn i'zsj xnruqj vzjxynts ij afsnyÃ©. Utzw tgyjsnw q'fzytwnxfynts ij xtwynj, nq stzx kfzy i'fgtwi zsj fzytwnxfynts rfwnyfqj, uznx zsj fzywj tkknhnjqqj. Â», Ã©hwny-jqqj ifsx zs htzwwnjw ifyÃ© iz 23 iÃ©hjrgwj 196722. Uznx ifsx zs fzywj htzwwnjw, ifyÃ© hjyyj ktnx iz 5 ofsanjw 1968, jqqj Ã©hwny jshtwj : Â« Oj hwfnsx gjfzhtzu ij s'fatnw ufx fxxje i'fwljsy inxutsngqj utzw atdfljw ozxvz'Ã  Ufwnx. Oj htruyfnx ozxyjrjsy xzw zsj fafshj ij Lfqqnrfwi utzw qj kfnwj. Rts rfwn utzwwfny r'fnijw rfnx oj sj qj ajzc ufx. Stzx sj xtrrjx ufx js ywÃ¨x gtsx yjwrjx jy oj anx Ã  xjx hwthmjyx ijuznx ansly fsx"
            langue = "Lituanien"
        ## Si un fichier est uploadÃ©, on rÃ©cupÃ¨re le contenu du fichier 
        elif st.session_state.demoType == "fichier":
            donnees_crypter = fichier_chiffre.read().decode("utf-8")

        ## Affichage du texte chiffrÃ©
        st.write("## Texte chiffrÃ©")
        st.write(donnees_crypter)

        ## Affichage du texte dÃ©chiffrÃ©
        st.write("## Texte dÃ©chiffrÃ©")
        st.write(dechiffrer_cesar(donnees_crypter, langue))

        ## Affichage des informations
        st.write("## Informations")
        ## Calcul de la diffÃ©rence entre le caractÃ¨re le plus frÃ©quent et le caractÃ¨re le plus frÃ©quent dans la langue
        diff = abs(difference_caracteres(caractere_plus_frequent(analyse_frequence(donnees_crypter)), freq_lang[langue]))

        ## Informations de base
        st.info(f"La lettre la plus frÃ©quente en **{langue}** est **{freq_lang[langue].upper()}**")
        st.info(f"Avec une clÃ© de **{diff}**, la lettre **{freq_lang[langue].upper()}** devient **{caractere_plus_frequent(analyse_frequence(donnees_crypter)).upper()}** aprÃ¨s chiffrement")

        ## Affichage des graphiques
        st.write("### FrÃ©quence des lettres du texte chiffrÃ©")
        st.bar_chart(analyse_frequence(donnees_crypter))
        st.write("### FrÃ©quence des lettres du texte dÃ©chiffrÃ©")
        st.bar_chart(analyse_frequence(dechiffrer_cesar(donnees_crypter, langue)))

        ## Affichage de la clÃ© de chiffrement
        st.write(f"### ClÃ© de chiffrement (valeur estimÃ©e) : {diff}")
        st.write(
            "La clÃ© de chiffrement est une valeur estimÃ©e Ã©tant donnÃ© que, dÃ¨s que l'on atteint le chiffre 26, l'alphabet recommence. Ainsi, plusieurs clÃ©s de chiffrement peuvent Ãªtre gÃ©nÃ©rÃ©es."
        )
        st.write(f"D'autres clÃ©s de chiffrement sont possibles, telles que : **{diff+26}, {diff+52}, ...**")
        st.write(f'La valeur **{diff}** est la plus petite possible et reprÃ©sente le nombre de lettres Ã  dÃ©caler pour chiffrer le texte.')

        ## Initialisation du dictionnaire contenant les Ã©lÃ©ments du graphique
        elements = []

        for i in range(26):
            elements.append({"data": {"id": f"c{str(i)}", "label": chr(i + 97).upper()}})
        for i in range(26):
            elements.append({"data": {"id": f"d{str(i)}", "label": chr(i + 97).upper()}})
        for i in range(26):
            elements.append({"data": {"source": f"c{str(i)}", "target": f"d{str((i + diff) % 26)}"}})

        ## Ajout de styles
        stylesheet = [
            {"selector": "node", "style": {"label": "data(label)", "width": 20, "height": 20}},
            {
                "selector": "edge",
                "style": {
                    "width": 3
                },
            },
            {
                "selector": "[id ^= 'c']",
                "style": {
                    "background-color": "#ff0000",
                    "shape": "rectangle",
                },
            },
            {
                "selector": "[id ^= 'd']",
                "style": {
                    "background-color": "#00ff00",
                    "shape": "rectangle",
                },
            },
        ]

        ## Configuration du layout du graphique
        layout = {"name": "grid", "rows": 2}

        ## Affichage du graphique
        st.write("## Visualisation")
        cytoscape(elements, stylesheet, key="graph", layout=layout)

    else:
        ## Si aucun texte chiffrÃ© n'est sÃ©lectionnÃ©, on affiche un message d'erreur
        st.warning("Aucun texte chiffrÃ© n'a Ã©tÃ© sÃ©lectionnÃ©")
except Exception as e:
    ## Si une erreur se produit, on affiche un message d'erreur
    st.error("Une erreur s'est produite")
    st.error(e)
